import { X1337x } from '../trackers/1337x';
import { RuTracker } from '../trackers/RuTracker';
import { ThePirateBay } from '../trackers/ThePirateBay';
import { TorrentSearch } from '../TorrentSearch';
import { SearchOptions } from '../types';

// –≠—Ç–æ—Ç —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ—Å—Ç—ã —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –∑–∞–ø—Ä–æ—Å–∞–º–∏ –∫ —Ç—Ä–µ–∫–µ—Ä–∞–º
// –ó–∞–ø—É—Å–∫–∞—Ç—å —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∞–ª—å–Ω—É—é —Ä–∞–±–æ—Ç—É

describe('Real Network Requests Tests', () => {
  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–∏ —Ç–µ—Å—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –¥–µ–ª–∞—é—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
  const runRealTests = process.env.RUN_REAL_TESTS === 'true';

  describe('1337x Real Requests', () => {
    const tracker = new X1337x();

    test.skipIf(!runRealTests)('should make real request to 1337x', async () => {
      console.log('\nüåê Making real request to 1337x...');
      
      const options: SearchOptions = { 
        query: 'inception', 
        limit: 5 
      };
      
      const startTime = Date.now();
      const results = await tracker.search('inception', options);
      const executionTime = Date.now() - startTime;
      
      console.log(`‚è±Ô∏è  Execution time: ${executionTime}ms`);
      console.log(`üìä Results found: ${results.length}`);
      
      if (results.length > 0) {
        console.log('üìù Sample results:');
        results.slice(0, 3).forEach((result, index) => {
          console.log(`  ${index + 1}. ${result.title}`);
          console.log(`     Size: ${result.size}, Seeders: ${result.seeders}, Leechers: ${result.leechers}`);
          console.log(`     Magnet: ${result.magnetUrl ? 'Yes' : 'No'}`);
          console.log(`     Torrent: ${result.torrentUrl ? 'Yes' : 'No'}`);
        });
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      expect(results.length).toBeGreaterThan(0);
      expect(results[0]).toHaveProperty('title');
      expect(results[0]).toHaveProperty('tracker', '1337x');
    }, 30000);

    test.skipIf(!runRealTests)('should handle 1337x search with filters', async () => {
      console.log('\nüåê Testing 1337x with category filter...');
      
      const options: SearchOptions = { 
        query: 'marvel', 
        category: 'movie',
        limit: 3 
      };
      
      const results = await tracker.search('marvel', options);
      
      console.log(`üìä Results with movie filter: ${results.length}`);
      
      if (results.length > 0) {
        console.log('üìù Filtered results:');
        results.forEach((result, index) => {
          console.log(`  ${index + 1}. ${result.title} (${result.category})`);
        });
      }
      
      expect(results.length).toBeGreaterThanOrEqual(0);
    }, 30000);
  });

  describe('RuTracker Real Requests', () => {
    const tracker = new RuTracker();

    test.skipIf(!runRealTests)('should make real request to RuTracker', async () => {
      console.log('\nüåê Making real request to RuTracker...');
      
      const options: SearchOptions = { 
        query: '–∞–≤–∞—Ç–∞—Ä', 
        limit: 5 
      };
      
      const startTime = Date.now();
      const results = await tracker.search('–∞–≤–∞—Ç–∞—Ä', options);
      const executionTime = Date.now() - startTime;
      
      console.log(`‚è±Ô∏è  Execution time: ${executionTime}ms`);
      console.log(`üìä Results found: ${results.length}`);
      
      if (results.length > 0) {
        console.log('üìù Sample results:');
        results.slice(0, 3).forEach((result, index) => {
          console.log(`  ${index + 1}. ${result.title}`);
          console.log(`     Size: ${result.size}, Seeders: ${result.seeders}, Leechers: ${result.leechers}`);
          console.log(`     Magnet: ${result.magnetUrl ? 'Yes' : 'No'}`);
          console.log(`     Torrent: ${result.torrentUrl ? 'Yes' : 'No'}`);
        });
      }
      
      expect(results.length).toBeGreaterThanOrEqual(0);
    }, 30000);

    test.skipIf(!runRealTests)('should handle RuTracker search with series filter', async () => {
      console.log('\nüåê Testing RuTracker with series filter...');
      
      const options: SearchOptions = { 
        query: '–≤–æ –≤—Å–µ —Ç—è–∂–∫–∏–µ', 
        category: 'series',
        limit: 3 
      };
      
      const results = await tracker.search('–≤–æ –≤—Å–µ —Ç—è–∂–∫–∏–µ', options);
      
      console.log(`üìä Results with series filter: ${results.length}`);
      
      if (results.length > 0) {
        console.log('üìù Filtered results:');
        results.forEach((result, index) => {
          console.log(`  ${index + 1}. ${result.title} (${result.category})`);
        });
      }
      
      expect(results.length).toBeGreaterThanOrEqual(0);
    }, 30000);
  });

  describe('ThePirateBay Real Requests', () => {
    const tracker = new ThePirateBay();

    test.skipIf(!runRealTests)('should make real request to ThePirateBay', async () => {
      console.log('\nüåê Making real request to ThePirateBay...');
      
      const options: SearchOptions = { 
        query: 'avatar', 
        limit: 5 
      };
      
      const startTime = Date.now();
      const results = await tracker.search('avatar', options);
      const executionTime = Date.now() - startTime;
      
      console.log(`‚è±Ô∏è  Execution time: ${executionTime}ms`);
      console.log(`üìä Results found: ${results.length}`);
      
      if (results.length > 0) {
        console.log('üìù Sample results:');
        results.slice(0, 3).forEach((result, index) => {
          console.log(`  ${index + 1}. ${result.title}`);
          console.log(`     Size: ${result.size}, Seeders: ${result.seeders}, Leechers: ${result.leechers}`);
          console.log(`     Magnet: ${result.magnetUrl ? 'Yes' : 'No'}`);
          console.log(`     Torrent: ${result.torrentUrl ? 'Yes' : 'No'}`);
        });
      }
      
      expect(results.length).toBeGreaterThanOrEqual(0);
    }, 30000);
  });

  describe('Integrated Search Real Requests', () => {
    const torrentSearch = new TorrentSearch();

    test.skipIf(!runRealTests)('should search across all trackers', async () => {
      console.log('\nüåê Making integrated search across all trackers...');
      
      const options: SearchOptions = { 
        query: 'disney', 
        limit: 10 
      };
      
      const startTime = Date.now();
      const response = await torrentSearch.search(options);
      const executionTime = Date.now() - startTime;
      
      console.log(`‚è±Ô∏è  Total execution time: ${executionTime}ms`);
      console.log(`üìä Total results: ${response.total}`);
      console.log(`üîç Query: "${response.query}"`);
      
      // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ —Ç—Ä–µ–∫–µ—Ä–∞–º
      const resultsByTracker = response.results.reduce((acc, result) => {
        if (!acc[result.tracker]) {
          acc[result.tracker] = [];
        }
        acc[result.tracker].push(result);
        return acc;
      }, {} as Record<string, any[]>);
      
      console.log('\nüìà Results by tracker:');
      Object.entries(resultsByTracker).forEach(([tracker, results]) => {
        console.log(`  ${tracker}: ${results.length} results`);
        if (results.length > 0) {
          console.log(`    Top result: ${results[0].title}`);
          console.log(`    Seeders: ${results[0].seeders}, Size: ${results[0].size}`);
        }
      });
      
      expect(response.total).toBeGreaterThanOrEqual(0);
      expect(response.executionTime).toBeGreaterThan(0);
    }, 60000);

    test.skipIf(!runRealTests)('should handle different query types', async () => {
      const testQueries = [
        'inception',
        'breaking bad',
        'marvel',
        'disney',
        '–∞–≤–∞—Ç–∞—Ä'
      ];
      
      for (const query of testQueries) {
        console.log(`\nüîç Testing query: "${query}"`);
        
        const options: SearchOptions = { 
          query, 
          limit: 5 
        };
        
        const startTime = Date.now();
        const response = await torrentSearch.search(options);
        const executionTime = Date.now() - startTime;
        
        console.log(`  ‚è±Ô∏è  Time: ${executionTime}ms, Results: ${response.total}`);
        
        if (response.total > 0) {
          console.log(`  üìù Top result: ${response.results[0].title}`);
        }
        
        expect(response.query).toBe(query);
        expect(response.executionTime).toBeGreaterThan(0);
        
        // –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }, 120000);
  });

  describe('Error Handling Real Tests', () => {
    const torrentSearch = new TorrentSearch();

    test.skipIf(!runRealTests)('should handle empty queries gracefully', async () => {
      const emptyQueries = ['', '   ', '\t\n'];
      
      for (const query of emptyQueries) {
        const response = await torrentSearch.search({ query, limit: 10 });
        expect(response.results).toEqual([]);
        expect(response.total).toBe(0);
        expect(response.executionTime).toBe(0);
      }
    });

    test.skipIf(!runRealTests)('should handle special characters', async () => {
      const specialQueries = [
        'test@#$%',
        '—Ç–µ—Å—Ç —Å –ø—Ä–æ–±–µ–ª–∞–º–∏',
        '123456',
        '!@#$%^&*()',
        'query with spaces'
      ];
      
      for (const query of specialQueries) {
        console.log(`\nüîç Testing special query: "${query}"`);
        
        try {
          const response = await torrentSearch.search({ query, limit: 3 });
          console.log(`  üìä Results: ${response.total}`);
          expect(response.query).toBe(query);
        } catch (error) {
          console.log(`  ‚ùå Error: ${error.message}`);
          // –ù–µ –ø–∞–¥–∞–µ–º –Ω–∞ –æ—à–∏–±–∫–∞—Ö, —Ç–∞–∫ –∫–∞–∫ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç—Ä–µ–∫–µ—Ä—ã –º–æ–≥—É—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
        }
        
        // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }, 60000);
  });
});